 第一节	基本概念介绍

	并发概念：两个或多个任务同时发生，一个程序同时执行多个独立的任务。
	进程：使一个可执行程序运行起来了就叫创建了一个进程。
	
	线程：1、每个进程都有一个主线程，主线程是唯一的，一个进程中只能有一个主线程。
	          2、当执行可执行程序产生一个进程后主线程就随着进程启动了，线程可以理解为是用来执行代码的。

	多线程：线程不是越多越好，每个线程都需要一个独立的堆栈空间，线程之前的切换需要保存很多中间状态会耗费本属于程序运行的时间。
	              多线程程序效率到底有多高，不是一个很容易评估和量化的东西。当多个线程占用同一个资源可能效率不高，但多线程用的恰当时
	              效率确实很高。


第二节	并发的实现条件
	1、多个进程实现并发 -> 进程间通讯
				1、同一电脑：管道、文件、消息队列、共享内存
				2、不同电脑：socket通信技术
	2、多个线程实现并发 -> 所有线程共享内存地址空间 但带来数据一致性问题(需要进行数据一致性控制)
	
	和进程相比线程的优缺点：
	1、线程启动更快 更轻量级
	2、系统资源开销更少 执行速度更快 共享内存的通讯方式是最快的
	3、使用有一定难度，要小心处理数据一致性问题

第三节	一、detach详解
		detach()：主线程不必等待子线程运行结束 -> 一般工程中建议使用join，很多问题都是因为使用detach造成的。
			一旦detach后，与主线程相关联的thread对象就会失去与主线程的关联，系统后台会接管该线程。如果此时主线程
			已运行完并进程退出而子线程还未运行完，这个子线程会驻留在后台运行(相当于被c++运行时库接管，当这个子线程
			运行完成后，由运行时库负责清理该线程相关的资源)

	二、其他创建线程手法：
		1、用类对象(重载了()操作符的类对象) 
			第一个坑：如果子线程类对象数据成员引用了主线程数据并且主线程调用了detach，若主线程已退出，此时子线程数据无效了。
		2、用lambda表达式创建线程
	
	三、线程传参详解，detach()大坑，成员函数做线程函数			
		1、传递临时对象作为线程参数
			1.1 主线程detach了子线程    传递的引用没问题  传递指针有问题
			1.2 隐式类型转换可能执行顺序有问题，程序可能并不按我们的想法来走(创建线程同时构造临时对象的方法传递参数是可行的)
			      一个事实：只要用临时构造的类对象作为参数传递给线程，那么就一定能在主线程执行完毕前把线程参数中第二个及以后的参数构建出来。
			1.3 总结
				1.3.1 若传递int这种简单类型参数，建议进行值传递，不要用引用
				1.3.2 如果传递类对象，避免隐式类型转换。全部都在创建线程这一行就构建出临时对象来，然后在函数参数里用引用作为形参。

	四、临时对象作为线程参数继续讲
		1、线程id：每个线程都对应着一个不同的数字，用std::this_thread::get_id()函数得到
		2、临时对象的构造时机与次数(用测试的方法观察可以得出结论)

	五、传递类对象、智能指针作为参数
		1、想它们不复制 用std::ref()函数
		2、对于智能指针unique_ptr<T>， 用std::move()函数进行传递

	六、成员函数也可以用来调用thread(第一个参数为成员函数，第二个参数为该类对象)

第四节	
	一、创建和等待多个线程
		1、多个线程执行顺序是乱的，与操作系统对线程的调度机制有关
		2、主线程等待所有子线程运行结束，最后主线程结束。
		3、把多个thread对象放入容器，方便一次循环整体管理。

	二、数据共享问题分析
		1、只读的数据是安全稳定的，不需要特别的处理手段
		2、同一数据有读有写会出问题，因为数据的写操作是分很多小步的，所有小步完成才算结束

第五节	互斥量概念、用法、死锁演示及解决详解
	一、互斥量(mutex)的基本概念
		互斥量是个类对象，理解成一把锁，多个线程尝试lock()成员函数加锁这把锁头，只有一个线程锁定成功(锁定成功后lock函数返回)，如果没有成功，就会不断地尝试去加锁
		需要加锁保护的数据需要不多也不少，少了没有达到保护效果，多了影响多线程运行效率。

	二、互斥量的用法
		1、lock和unlock要成对使用(在ifelse等分支语句中，程序每一个分支都要解锁)
		2、有lock而忘记unlock的情况非常难排查，为防止忘记unlock，引入了一个叫lock_guard的类模板 它可以直接取代lock和unlock
			lock_guard<mutex> sbguard(my_mutex); -> sbguard构造函数中调用my_mutex的lock成员方法，sbguard析构时自动unlock    ->    缺点是不够灵活

	三、死锁 -> 这个问题产生的前提条件是至少有两个互斥量
		3.1 死锁演示
		3.2 死锁的一般解决方案 -> 只要保证两个或多个互斥量加锁顺序一致，就不会出现死锁
		3.3 lock函数模板(c++11新特性，处理多个互斥量才出场) 可以一行代码内锁住多个互斥量避免死锁风险(但工程中不常见)
			调用示例 -> std::lock(my_mutex1, my_mutex2);
			lock函数模板工作原理 -> 锁定第一个互斥量，如果成功就锁下一个，所有互斥量都锁定成功再进行下一步，但锁定时候要是有任何一个失败，就释放所有锁定的互斥量
		3.4 lock_guard的std::adopt_lock参数
			lock_guard<mutex> sbguard1(my_mutex1, std::adopt_lock) my_mutex1之前锁过一次，在lock_guard<mutex>类对象的构造函数中就不会再次调用my_mutex1的lock成员函数了

第六节	unique_lock详解
	一、unique_lock是一个类模板 可以完全取代lock_guard 但一般工作中lock_guard的功能已经足够 unique_lock比lock_guard灵活很多，但效率、内存都差一点
	
	二、unique_lock第二个参数详解(unique_lock支持的一些标记)
		1、adopt_lock -> 表示这个unique_lock<mutex>类对象的构造函数中的互斥量已经加锁(lock)过了
		2、try_to_lock -> 尝试lock，如果没有锁定成功也立即返回而不会阻塞。可以配合后续的 .owns_lock()成员函数来根据是否拿到锁来组织代码。
		3、defer_lock -> 使用前提：不能提前lock unique_lock<mutex>类对象构造函数中的互斥量，且初始化unique_lock<mutex>类对象时，互斥量仍没有加锁，得调用unique_lock<mutex>类对象的lock成员函数。
	
	三、unique_lock的成员函数
		lock	unlock	try_lock	release(返回它所管理的mutex对象指针，并且释放所有权，如果之前没有通过unique_lock解锁需要自己在后续解锁)
	
	四、unique_lock所有权传递
		1、利用std::move()函数
		2、移动构造(函数中return unique_lock<mutex>类型的局部对象)


第七节	单例模式共享数据分析、解决	call_once
	一、设计模式大概谈
		程序灵活，维护起来可能方便，但别人接管，阅读代码都困难，设计模式有其独特优点，但要活学活用，不要生搬硬套

	二、单例设计模式 -> 使用频率较高，整个项目中某些类的对象只能创建一个

	三、单例设计模式共享数据问题分析、解决 -> 问题：需在子线程中创建单例类的对象，且这种线程不止一个。 解决：对创建单例对象的代码进行加锁操作。
		为提高效率 可以使用  “双重锁定技术”

	四、call_once() c++11引入的函数 -> 保证函数只被调用一次 具备互斥量这种能力 效率更高  第一个参数是once_flag(c++定义的一个结构对象) 第二个参数是函数名

第八节	condition_variable	wait()	notify_one()	notify_all()
	
	一、条件变量std::condition_variable、wait()、notify_one()
		std::condition_variable是一个和条件相关的类，等待一个条件达成，需要和互斥量配合工作，用的时候要生成该类对象。
		
		wait()第一个参数是一个mutex/unique_lock<mutex> 类型对象
		wait()用来等一个东西
		如果第二个参数lambda表达式返回值是true，wait()直接返回；
		如果第二个参数lambda表达式返回值是false或者没有第二个参数，将wait()解锁互斥量，并处于睡眠状态堵塞到本行；
		睡眠堵塞状态保持到其他某个线程调用notify_one()成员函数为止;
		当wait()被唤醒，就开始不断地尝试重新获取互斥量，直到获取到互斥量后就开始如下逻辑：
			(1)如果第二个参数lambda表达式还是false，则wait()解锁互斥量，并处于睡眠状态堵塞到本行； //相当于继续重复
			(2)如果第二个参数lambda表达式是ture，wait()返回，流程得以往下；
			(3)如果没有第二个参数，wait()返回，流程得以往下。
	
	二、上述代码思考 -> 稳定压倒一切 所有函数完全弄懂了再使用 否则使用基础的函数
	
	三、notify_all()
		notify_one()只能通知一个线程唤醒(如果此时有多个线程的std::condition_variable对象都等待唤醒，则随机唤醒其中一个)；
		notify_all()通知所有线程的该std::condition_variable对象唤醒。
		但是notify()成员函数不是总有效的，比如A线程根本还没有在wait()这一行堵塞住，B线程就调用了notify()函数，则A线程不会有任何反应
		B线程的notify()成员函数只有在A线程处于wait()堵塞时才能成功进行通知唤醒行为。


第九节	async、future、packaged_task、promise
	
	一、async、future创建后台任务并返回值
		async是个函数模板，用来启动一个异步任务，返回一个future对象，future是个类模板
		启动异步任务：自动创建一个线程并开始执行入口函数，返回一个future对象，这个future对象内含有线程入口函数的返回值，可以调用future对象个get()成员函数获取该值
		
		future对象的wait()成员函数 -> 等待线程返回，但本身不返回结果 类似于线程的join()成员函数
		future对象的get()成员函数只能调用一次
		
		std::launch枚举类型
			std::launch::async		在调用async()函数时就已经开始创建线程并且立即运行
			std::launch::deferred		延迟线程调用直到遇到future对象的get()/wait_for()成员函数，如果没有get()/wait_for()成员函数调用连入口函数都不运行，并且没有创建新线程

		
	二、std::packaged_task 打包任务，是个类模板	->	目前觉得用处不大
		它的模板参数是各种可调用对象，通过packaged_task来把各种可调用对象奥装起来，方便将来作为线程入口函数。	 


	三、std::promise 类模板
		能够在某个线程中使用该类模板的set_value()成员函数为其赋值，然后在其他线程中通过promise对象中的future对象将值取出。

第十节	std::future的其他成员函数、shared_future()、atomic原子操作

	一、std::future的wait_for()成员函数 -> 等待一定的时间，返回一个future_status枚举类型变量
		1、timeout 超时，线程还没有执行完毕
		2、ready 线程已经成功返回
		3、deferred延迟，async()调用时第一个参数设置为std::launch::deferred时候是这个状态。
	      .valid()成员函数 -> 判断是否能获取到值，返回bool类型
	
	二、shared_future是个类模板，其get()方法是复制数据 因此可以多次获取值	而future对象的get()方法是移动语义 因此只能调用一次
	
	三、原子操作std::atomic -> 理解成一种不需要互斥量加锁技术的多线程并发编程技术
		3.1 原子操作概念引出范例
			原子操作：在多线程中不会被打断的程序执行片段，指不可分割的操作，不会有中间状态，要么完成了要么就还没开始做
			互斥量加锁一般是针对一个代码段
			原子操作一般是针对一个变量，而不是一个代码段
			原子操作语法： std::atomic<int> g_mycount = 0; //g_mycount对象则是一个支持原子操作的对象
		3.2 经验
			原子操作一般用于计数或者统计
			一般原子操作针对++ / -- / += / &= / |= / ^= 是支持的，其他符号操作不一定支持。

第十一节	async深入谈
	二、async深入谈
		2.1 async参数详述
			std::thread()如果系统资源紧张，可能创建线程失败，执行std::thread()时整个程序可能崩溃
			std::async()我们一般不称它为创建线程(即使它能创建线程)，我们一般称它创建了一个异步任务
			thread、async最大的区别在于async有时候并不一定创建新线程
		
			a).调用async()时第一个参数是 launch::async | launch::deferred 时，调用async()的行为可能是这两种当中的一种，操作系统会根据当时的情况评估并选择合适的使用。
			b).调用async()时不带launch参数，其默认值和a效果完全一致。调用async()的行为可能是这两种当中的一种，操作系统会根据当时的情况评估并选择合适的使用。

		2.2 async和thread的区别
			thread创建线程可能会失败导致程序崩溃
			thread创建线程，想拿到其返回值是不容易的
		
		2.3不加参数的async()调用不确定性问题处理
			利用future对象的wait_for()成员函数的三种返回结果进行判断 -> timeout ready 是创建了新线程 deferred是没有创建新线程。

第十二节	


		
		

	




		
	