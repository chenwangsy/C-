第一节	基本概念介绍

	并发概念：两个或多个任务同时发生，一个程序同时执行多个独立的任务。
	进程：使一个可执行程序运行起来了就叫创建了一个进程。
	
	线程：1、每个进程都有一个主线程，主线程是唯一的，一个进程中只能有一个主线程。
	          2、当执行可执行程序产生一个进程后主线程就随着进程启动了，线程可以理解为是用来执行代码的。

	多线程：线程不是越多越好，每个线程都需要一个独立的堆栈空间，线程之前的切换需要保存很多中间状态会耗费本属于程序运行的时间。
	              多线程程序效率到底有多高，不是一个很容易评估和量化的东西。当多个线程占用同一个资源可能效率不高，但多线程用的恰当时
	              效率确实很高。


第二节	并发的实现条件
	1、多个进程实现并发 -> 进程间通讯
				1、同一电脑：管道、文件、消息队列、共享内存
				2、不同电脑：socket通信技术
	2、多个线程实现并发 -> 所有线程共享内存地址空间 但带来数据一致性问题(需要进行数据一致性控制)
	
	和进程相比线程的优缺点：
	1、线程启动更快 更轻量级
	2、系统资源开销更少 执行速度更快 共享内存的通讯方式是最快的
	3、使用有一定难度，要小心处理数据一致性问题

第三节	一、detach详解
		detach()：主线程不必等待子线程运行结束 -> 一般工程中建议使用join，很多问题都是因为使用detach造成的。
			一旦detach后，与主线程相关联的thread对象就会失去与主线程的关联，系统后台会接管该线程。如果此时主线程
			已运行完并进程退出而子线程还未运行完，这个子线程会驻留在后台运行(相当于被c++运行时库接管，当这个子线程
			运行完成后，由运行时库负责清理该线程相关的资源)

	二、其他创建线程手法：
		1、用类对象(重载了()操作符的类对象) 
			第一个坑：如果子线程类对象数据成员引用了主线程数据并且主线程调用了detach，若主线程已退出，此时子线程数据无效了。
		2、用lambda表达式创建线程
	
	三、线程传参详解，detach()大坑，成员函数做线程函数			
		1、传递临时对象作为线程参数
			1.1 主线程detach了子线程    传递的引用没问题  传递指针有问题
			1.2 隐式类型转换可能执行顺序有问题，程序可能并不按我们的想法来走(创建线程同时构造临时对象的方法传递参数是可行的)
			      一个事实：只要用临时构造的类对象作为参数传递给线程，那么就一定能在主线程执行完毕前把线程参数中第二个及以后的参数构建出来。
			1.3 总结
				1.3.1 若传递int这种简单类型参数，建议进行值传递，不要用引用
				1.3.2 如果传递类对象，避免隐式类型转换。全部都在创建线程这一行就构建出临时对象来，然后在函数参数里用引用作为形参。

	四、临时对象作为线程参数继续讲
		1、线程id：每个线程都对应着一个不同的数字，用std::this_thread::get_id()函数得到
		2、临时对象的构造时机与次数(用测试的方法观察可以得出结论)

	五、传递类对象、智能指针作为参数
		1、想它们不复制 用std::ref()函数
		2、对于智能指针unique_ptr<T>， 用std::move()函数进行传递

	六、成员函数也可以用来调用thread(第一个参数为成员函数，第二个参数为该类对象)

第四节	
	一、创建和等待多个线程
		1、多个线程执行顺序是乱的，与操作系统对线程的调度机制有关
		2、主线程等待所有子线程运行结束，最后主线程结束。
		3、把多个thread对象放入容器，方便一次循环整体管理。

	二、数据共享问题分析
		1、只读的数据是安全稳定的，不需要特别的处理手段
		2、同一数据有读有写会出问题，因为数据的写操作是分很多小步的，所有小步完成才算结束

第五节	互斥量概念、用法、死锁演示及解决详解
	一、互斥量(mutex)的基本概念
		互斥量是个类对象，理解成一把锁，多个线程尝试lock()成员函数加锁这把锁头，只有一个线程锁定成功(锁定成功后lock函数返回)，如果没有成功，就会不断地尝试去加锁
		需要加锁保护的数据需要不多也不少，少了没有达到保护效果，多了影响多线程运行效率。

	二、互斥量的用法
		1、lock和unlock要成对使用(在ifelse等分支语句中，程序每一个分支都要解锁)
		2、有lock而忘记unlock的情况非常难排查，为防止忘记unlock，引入了一个叫lock_guard的类模板 它可以直接取代lock和unlock
			lock_guard<mutex> sbguard(my_mutex); -> sbguard构造函数中调用my_mutex的lock成员方法，sbguard析构时自动unlock    ->    缺点是不够灵活

	三、死锁 -> 这个问题产生的前提条件是至少有两个互斥量
		3.1 死锁演示
		3.2 死锁的一般解决方案 -> 只要保证两个或多个互斥量加锁顺序一致，就不会出现死锁
		3.3 lock函数模板(c++11新特性，处理多个互斥量才出场) 可以一行代码内锁住多个互斥量避免死锁风险(但工程中不常见)
			调用示例 -> std::lock(my_mutex1, my_mutex2);
			lock函数模板工作原理 -> 锁定第一个互斥量，如果成功就锁下一个，所有互斥量都锁定成功再进行下一步，但锁定时候要是有任何一个失败，就释放所有锁定的互斥量
		3.4 lock_guard的std::adopt_lock参数
			lock_guard<mutex> sbguard1(my_mutex1, std::adopt_lock) my_mutex1之前锁过一次，在lock_guard<mutex>类对象的构造函数中就不会再次调用my_mutex1的lock成员函数了

第六节	unique_lock详解
	一、unique_lock是一个类模板 可以完全取代lock_guard 但一般工作中lock_guard的功能已经足够 unique_lock比lock_guard灵活很多，但效率、内存都差一点
	
	二、unique_lock第二个参数详解(unique_lock支持的一些标记)
		1、adopt_lock -> 表示这个unique_lock<mutex>类对象的构造函数中的互斥量已经加锁(lock)过了
		2、try_to_lock -> 尝试lock，如果没有锁定成功也立即返回而不会阻塞。可以配合后续的 .owns_lock()成员函数来根据是否拿到锁来组织代码。
		3、defer_lock -> 使用前提：不能提前lock unique_lock<mutex>类对象构造函数中的互斥量，且初始化unique_lock<mutex>类对象时，互斥量仍没有加锁，得调用unique_lock<mutex>类对象的lock成员函数。
	
	三、unique_lock的成员函数
		lock	unlock	try_lock	release(返回它所管理的mutex对象指针，并且释放所有权，如果之前没有通过unique_lock解锁需要自己在后续解锁)
	
	四、unique_lock所有权传递
		1、利用std::move()函数
		2、移动构造(函数中return unique_lock<mutex>类型的局部对象)

	 


		
		

	




		
	